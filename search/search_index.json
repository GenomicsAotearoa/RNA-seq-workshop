{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"RNA-Seq Data Analysis <p>This RNA-Seq workshop aims to get you started with your own RNA-seq analysis and assumes you are already familiar with the basics of bash and R.</p>"},{"location":"#content","title":"Content","text":"Lesson Overview 1. Background General overview of a RNA-Seq workflow 2. Quality Assessment Assess the quality of data, How to use FastQC and MultiQC 3. Trimming and Filtering How to remove adapter sequences 4. Mapping and Count Align/Map reads back to genome and number of reads from each sample that originated from that gene. 5. Differential Expression Analysis Differential expression analysis with R 6. Over-representation analysis Determine whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list Supplementary 1 - A Guide to RNA-Seq Supplementary 2 - Lecture notes : DE analysis Supplementary 3 - Lecture notes : Annotation Data &amp; Gene Set Analysis <p>Attribution notice</p> <ul> <li> <p>The material used to prepare for the workshop was extracted from Professor.Mik Black's lectures for STAT435 - Data Analysis for Bioinformatics (University of Otago, Dunedin, New Zealand).</p> </li> <li> <p>Some code used in this workshop has been extracted from a collection of presentations, workshops and lectures by Prof. Thomas Girke, Institute for Integrative Genome Biology, UC Riverside: Link_1 and Link_2</p> </li> </ul>"},{"location":"1_background/","title":"RNA-seq Workflow","text":"<p>Objectives</p> <ul> <li>Develop an understanding of the five stages of the RNA-seq workflow</li> <li>Develop an awareness of the steps and tools involved in analysing RNA-seq data</li> </ul> <p>Before beginning an RNA-Seq experiment, you should understand and carefully consider each step of the RNA-Seq workflow: Experimental design, Extraction, Library preparation, Sequencing, and Data analysis.</p> <p> </p> <p></p> <p>Exercises</p> <ul> <li>Rank genes based on expression?</li> <li>Identify differentially expressed genes after inducing a drug</li> <li>Identify Novel transcripts</li> <li>Identify bacterial and eukaryotic genes in a sample</li> </ul> <p>Yeast Dataset</p> <p>This workshop uses the dataset from yeast RNA-seq experiment, Lee et al 2008 </p> <ul> <li>Wild-type versus RNA degradation mutants</li> <li>Subset of data (chromosome 1)</li> <li>Six samples (3 WT / 3 MT)</li> <li>Single end sequencing</li> </ul>"},{"location":"1_background/#experimental-design","title":"Experimental design","text":"<p>The design stage of your experiment is arguably the most critical step in ensuring the success of an RNA-Seq experiment. Researchers must make key decisions at the start of any NGS project, including the type of assay and the number of samples to analyze. The optimal approach will depend largely on the objectives of the experiment, hypotheses to be tested, and expected information to be gathered.</p>"},{"location":"1_background/#extraction","title":"Extraction","text":"<p>The first step in characterizing the transcriptome involves isolating and purifying cellular RNA. The quality and quantity of the input material have a significant impact on data quality; therefore, care must be taken when isolating and preparing RNA for sequencing. Given the chemical instability of RNA, there are two major reasons for RNA degradation during experiments: - RNA contains ribose sugar and is not stable in alkaline conditions because of the reactive hydroxyl bonds. RNA is also more prone to heat degradation than DNA. -  Ribonucleases (RNases) are ubiquitous and very stable, so avoiding them is nearly impossible. It is essential to maintain an RNase-free environment by wearing sterile disposable gloves when handling reagents and RNA samples, employing RNase inhibitors, and using DEPC-treated water instead of PCR-grade water. Additionally, proper storage of RNA is crucial to avoid RNA degradation.</p> <p>In the short term, RNA may be stored in RNase-free water or TE buffer at -80\u00b0C for 1 year without degradation. For the long term, RNA samples may be stored as ethanol precipitates at -20\u00b0C. Avoid repeated freeze-thaw cycles of samples, which can lead to degradation. RNA of high integrity will maximize the likelihood of obtaining reliable and informative results.</p>"},{"location":"1_background/#library-preparation","title":"Library Preparation","text":"<p>This involves generating a collection of RNA fragments that are compatible for sequencing. The process involves enrichment of target (non-ribosomal) RNA, fragmentation, reverse transcription (i.e. cDNA synthesis), and addition of sequencing adapters and amplification. The enrichment method determines which types of transcripts (e.g. mRNA, lncRNA, miRNA) will be included in the library. In addition, the cDNA synthesis step can be performed in a such a way as to maintain the original strand orientation of the transcript, generating what is known as \u2018strand-specific\u2019 or \u2018directional\u2019 libraries.</p>"},{"location":"1_background/#sequencing","title":"Sequencing","text":"<p>Parameters for sequencing\u2014such as read length, configuration, and output\u2014depend on the goals of your project and will influence your choice of instrument and sequencing chemistry. The main NGS technologies can be grouped into two categories: short-read (or \u2018second generation\u2019) sequencing, and long-read (or \u2018third generation\u2019) sequencing. Both have distinct benefits for RNA-Seq. - Short-read sequencing is relatively inexpensive on a per-base basis and can generate billions of reads in a massively parallel manner, with single-end read lengths ranging between 50 and 300 bp. The high-throughput nature of this technology is ideal for quantifying the relative abundance of transcripts or identifying rare transcripts. Several platforms available on the market offer flexible outputs using roughly similar chemistry. Each cDNA fragment can be sequenced from only one end, called single-end (SE) sequencing, or both ends, called paired-end (PE) sequencing. The former is generally less expensive and faster than the latter. However, paired-end sequencing helps detect genomic rearrangements and repetitive sequence alignments better than the single- end configuration, since more information is collected from each fragment. - Long-read sequencing can resolve inaccessible regions of the genome and read through the entire length of RNA transcripts, allowing precise determination of specific isoforms. Two of the leading long-read sequencing platform providers include Pacific Biosciences (PacBio), and Oxford Nanopore Technologies\u00ae.</p> <p>However, if cost reduction is paramount and/or high data output is required, short-read sequencing is a better choice.</p>"},{"location":"1_background/#data-analysis","title":"Data Analysis","text":"<p>Evaluating your data quality and extracting biologically relevant information is the final and most rewarding step in an RNA-Seq experiment. It is important to discuss your project with an experienced bioinformatician to find the best analysis pipeline for your data. One pipeline does not fit all approaches.</p>"},{"location":"1_background/#overview-of-illumina-sequencing","title":"Overview of Illumina Sequencing","text":"<p>Here is a video to illumina sequencing.</p>"},{"location":"2_qualityassessment/","title":"Quality control of the sequencing data.","text":"<p>Objectives</p> <ul> <li>Assess the quality of your data</li> <li>Use FastQC package to do quality check</li> <li>Use MultiQC to view our analysis results</li> </ul> <p> </p> <p>Several tools available to do quality assessment. For this workshop, we will use <code>fastqc</code>.</p> <p>First, it is always good to verify where we are:</p> <pre><code>cd ~\npwd\n</code></pre> <pre><code>    /home/$USER\n# good I am ready to work\n</code></pre> <p>Checking to make sure we have the Raw files for the workshop.</p> <p><pre><code>ls\n</code></pre> <pre><code>    RNA_seq ...\n</code></pre></p> <p>Creating a directory where to store the QC data:</p> <p><pre><code>cd RNA_seq\nls\n</code></pre> <pre><code>    Genome  Raw  rsmodules.sh  yeast_counts_all_chr.txt\n</code></pre></p> <pre><code>mkdir QC\n</code></pre> <p>Since we are working on the NeSI HPC, we need to search and load the software/application before we can use it.</p> Note: Accessing and Deploying software with <code>module</code> command\" <ul> <li>View available modules</li> </ul> <pre><code>#View all modules\nmodule avail\n\n# View all modules which match the keyword in their name\nmodule avail KEYWORD\n\n# View all modules which match the keyword in their name or description\nmodule spider KEYWORD\n</code></pre> <ul> <li> <p>Load a specific program</p> <p>All module names on NeSI Software stack have a version and toolchain/environment suffixes. If none is specified, then the default version of the software is loaded. The default version can be seen with the <code>module avail modulename</code> command (corresponding module name will have <code>(D)</code> suffix)</p> </li> </ul> <pre><code>module load Module_Name\n</code></pre> <ul> <li>Unload all current modules</li> </ul> <pre><code>module purge\n</code></pre> <p>Please do not use <code>$module --force purge</code></p> <ul> <li>Swap a currently loaded module for a different one</li> </ul> <pre><code>module switch CURRENT_MODULE DESIRED_MODULE\n</code></pre> <ul> <li>Search whether the software is available as a module with <code>module spider</code> command. </li> </ul> <pre><code>module spider fastqc\n</code></pre> <p>and then load </p> <pre><code>module purge\nmodule load FastQC/0.11.9\n</code></pre> <p>Warning</p> <p>module name used for <code>module spider</code> is case insensitive.i.e. <code>fastqc</code> will respond and show the available modules matching the string. However, module name for <code>module load</code> command is case sensitive. Therefore, we recommend copying and pasting the name/version of it from the spider list</p> <p>Load all modules at once</p> <p>There is a file named rsmodules.sh which is a shell script to load the required modules at once. Running <code>source ~/RNA_seq/rsmodules.sh</code> command will execute it. </p> <p>Now we can start the quality control:</p> <p><pre><code>fastqc -o QC/ Raw/*\n</code></pre> You will see an automatically updating output message telling you the progress of the analysis. It will start like this:</p> <pre><code>    Started analysis of SRR014335-chr1.fastq\n    Approx 5% complete for SRR014335-chr1.fastq\n    Approx 10% complete for SRR014335-chr1.fastq\n    Approx 15% complete for SRR014335-chr1.fastq\n    Approx 20% complete for SRR014335-chr1.fastq\n    Approx 25% complete for SRR014335-chr1.fastq\n    Approx 30% complete for SRR014335-chr1.fastq\n    Approx 35% complete for SRR014335-chr1.fastq\n</code></pre> <p>The FastQC program has created several new files within our ~/RNA_seq/QC/ directory.</p> <p><pre><code>ls QC\n</code></pre> <pre><code>    SRR014335-chr1_fastqc.html  SRR014336-chr1_fastqc.zip   SRR014339-chr1_fastqc.html  SRR014340-chr1_fastqc.zip\n    SRR014335-chr1_fastqc.zip   SRR014337-chr1_fastqc.html  SRR014339-chr1_fastqc.zip   SRR014341-chr1_fastqc.html\n    SRR014336-chr1_fastqc.html  SRR014337-chr1_fastqc.zip   SRR014340-chr1_fastqc.html  SRR014341-chr1_fastqc.zip\n</code></pre></p>"},{"location":"2_qualityassessment/#viewing-the-fastqc-results","title":"Viewing the FastQC results","text":""},{"location":"2_qualityassessment/#working-with-the-fastqc-text-output","title":"Working with the FastQC text output","text":"<p>Now that we\u2019ve looked at our HTML reports to get a feel for the data, let\u2019s look more closely at the other output files. Go back to the tab in your terminal program that is connected to NeSI and make sure you\u2019re in our results subdirectory.</p> <p><pre><code>cd ~/RNA_seq/QC\nls\n</code></pre> <pre><code>    SRR014335-chr1_fastqc.html  SRR014336-chr1_fastqc.zip   SRR014339-chr1_fastqc.html  SRR014340-chr1_fastqc.zip\n    SRR014335-chr1_fastqc.zip   SRR014337-chr1_fastqc.html  SRR014339-chr1_fastqc.zip   SRR014341-chr1_fastqc.html\n    SRR014336-chr1_fastqc.html  SRR014337-chr1_fastqc.zip   SRR014340-chr1_fastqc.html  SRR014341-chr1_fastqc.zip\n</code></pre> Let's unzip the files to look at the FastQC text file outputs.</p> <pre><code>for filename in *.zip\ndo\nunzip $filename\ndone\n</code></pre> <p>Inside each unzipped folder, there is a summary text which shows results of the statistical tests done by FastQC</p> <p><pre><code>ls SRR014335-chr1_fastqc\n</code></pre> <pre><code>    fastqc_data.txt  fastqc.fo  fastqc_report.html  Icons/  Images/  summary.txt\n</code></pre></p> <p>Use less to preview the summary.txt file</p> <pre><code>less SRR014335-chr1_fastqc/summary.txt\n</code></pre> <p>We can make a record of the results we obtained for all our samples by concatenating all of our summary.txt files into a single file using the cat command. We\u2019ll call this fastqc_summaries.txt.</p> <pre><code>cat */summary.txt &gt; ~/RNA_seq/QC/fastqc_summaries.txt \n</code></pre> <ul> <li>Have a look at the fastqc_summaries.txt and search for any of the samples that have failed the QC statistical tests.</li> </ul>"},{"location":"2_qualityassessment/#multiqc-multi-sample-analysis","title":"MultiQC -  multi-sample analysis","text":"<ul> <li>The FastQC analysis is applied to each sample separately, and produces a report for each.</li> <li>The application MultiQC provides a way to combine multiple sets of results (i.e., from MANY   different software packages) across multiple samples.</li> <li>To generate <code>multiqc</code> results, run the following command in the directory with the output files you want to summarise (e.g., fastqc reports generated above):</li> </ul> <p><pre><code>module load MultiQC/1.13-gimkl-2022a-Python-3.10.5\ncd ~/RNA_seq/\nmkdir MultiQC\ncd MultiQC\ncp ../QC/* ./\nmultiqc .\nls -F\n</code></pre> <pre><code>    multiqc_data/  multiqc_report.html\n</code></pre> The html report shows the MultiQC summary</p> <p></p> <p>Back to homepage</p>"},{"location":"3_trimmingfiltering/","title":"Cleaning Reads","text":"<p>Objectives</p> <ul> <li>Understand what adapters are</li> <li>Understand that trimming can be done based on Phred scores or sequence</li> </ul> <p> </p> <p>In the previous section, we took a high-level look at the quality of each of our samples using FastQC. We visualized per-base quality graphs showing the distribution of read quality at each base across all reads in a sample and extracted information about which samples fail which quality checks. Some of our samples failed quite a few quality metrics used by FastQC. This doesn\u2019t mean, though, that our samples should be thrown out! It\u2019s very common to have some quality metrics fail, and this may or may not be a problem for your downstream application. </p>"},{"location":"3_trimmingfiltering/#adapter-removal","title":"Adapter removal","text":"<ul> <li>\"Adapters\" are short DNA sequences that are added to each read as part of the sequencing process (we won't get into \"why\" here).</li> <li>These are removed as part of the data generation steps that occur during the sequencing run, but sometimes there is still a non-trivial amount of adapter sequence present in the FASTQ files.</li> <li>Since the sequence is not part of the target genome (i.e., the genome if the species from which teh samples were derived) then we need to remove it to prevent it affecting the downstream analysis.</li> <li>The FastQC application get detection adapter contamination in samples.</li> </ul> <p>We will use a program called CutAdapt to filter poor quality reads and trim poor quality bases from our samples.</p>"},{"location":"3_trimmingfiltering/#how-to-act-on-fastq-after-qc","title":"How to act on fastq after QC.","text":"<p>We can do several trimming:</p> <ul> <li>on quality using Phred score. What will be the Phred score?</li> <li>on the sequences, if they contain adaptor sequences.</li> </ul> <p>To do so, we can use on tools: The cutadapt application is often used to remove adapter sequence from FASTQ files. - The following syntax will remove the adapter sequence AACCGGTT from the file SRR014335-chr1.fastq, create a new file called SRR014335-chr1_trimmed.fastq, and write a summary to the log file SRR014335-chr1.log:</p> <p><pre><code>pwd\n</code></pre> <pre><code>    /home/$USER/RNA_seq\n</code></pre> <pre><code>mkdir Trimmed\nmodule load cutadapt/4.1-gimkl-2022a-Python-3.10.5\ncutadapt -q 20 -a AACCGGTT -o Trimmed/SRR014335-chr1_cutadapt.fastq Raw/SRR014335-chr1.fastq &gt; Trimmed/SRR014335-chr1.log\n</code></pre></p> <ul> <li>-q (<code>--quality-cutoff</code>)  parameter can be used to trim low-quality ends from reads. If you specify a single cutoff value, the 3\u2019 end of each read is trimmed.</li> </ul> <pre><code>less Trimmed/SRR014335-chr1.log\n</code></pre> <p>Now we should trim all samples.</p> <p><pre><code>cd Raw\nls\n</code></pre> <pre><code>SRR014335-chr1.fastq  SRR014336-chr1.fastq  SRR014337-chr1.fastq  SRR014339-chr1.fastq  SRR014340-chr1.fastq  SRR014341-chr1.fastq\n</code></pre> <pre><code>for filename in *.fastq\ndo \nbase=$(basename ${filename} .fastq)\ncutadapt -q 20 -a AACCGGTT -o ../Trimmed/${base}.trimmed.fastq ${filename} &gt; ../Trimmed/${base}.log\ndone\n</code></pre></p>"},{"location":"3_trimmingfiltering/#multiqc-cutadapt-log-files","title":"MultiQC: <code>cutadapt</code> log files","text":"<ul> <li>If the log files from <code>cutadapt</code> are added to the directory containing the FastQC output, this information will also be incorporated into the MultiQC report the next time it is run.</li> </ul> <p><pre><code>cd ../MultiQC\ncp ../Trimmed/*log .\nmultiqc .\n</code></pre> </p> <p>Back to homepage</p>"},{"location":"4_mappingANDcount/","title":"Mapping and Counting","text":"<p>Objectives</p> <ul> <li>Learn how to index a reference genome</li> <li>Align sequence reads to an indexed reference genome</li> <li>Generate read counts for each exon in the genome</li> </ul> <p> </p> <p>RNA-seq generate gene expression information by quantifying the number of transcripts (per gene) in a sample. This is accomplished by counting the number of transcripts that have been sequenced - the more active a gene is, the more transcripts will be in a sample, and the more reads will be generated from that transcript.</p> <p>For RNA-seq, we need to align or map each read back to the genome, to see which gene produced it. - Highly expressed genes will generate lots of transcripts, so there will be lots of reads that map back to the position of that transcript in the genome. - The per-gene data we work with in an RNA-seq experiment are counts: the number of reads from each sample that originated from that gene.</p>"},{"location":"4_mappingANDcount/#preparation-of-the-genome","title":"Preparation of the genome","text":"<p>To be able to map (align) sequencing reads on the genome, the genome needs to be indexed first. In this workshop we will use HISAT2. Note for speed reason, the reads will be aligned on the chr5 of the Yeast genome.</p> <p><pre><code>cd /home/$USER/RNA_seq/Genome\n\n#to list what is in your directory:\nls /home/$USER/RNA_seq/Genome\n</code></pre> <pre><code>    Saccharomyces_cerevisiae.R64-1-1.99.gtf  Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\n</code></pre> <pre><code>module load HISAT2/2.2.1-gimpi-2022a\n\n# index file:\nhisat2-build -p 4 -f Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa Saccharomyces_cerevisiae.R64-1-1.dna.toplevel\n\n#list what is in the directory:\nls /home/$USER/RNA_seq/Genome\n</code></pre> <pre><code>Saccharomyces_cerevisiae.R64-1-1.99.gtf              Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.4.ht2  Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.8.ht2\nSaccharomyces_cerevisiae.R64-1-1.dna.toplevel.1.ht2  Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.5.ht2  Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\nSaccharomyces_cerevisiae.R64-1-1.dna.toplevel.2.ht2  Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.6.ht2\nSaccharomyces_cerevisiae.R64-1-1.dna.toplevel.3.ht2  Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.7.ht2\n</code></pre></p> <ul> <li>-p number of threads</li> <li>-f fasta file</li> </ul> <p>How many files were created during the indexing process?</p>"},{"location":"4_mappingANDcount/#alignment-on-the-genome","title":"Alignment on the genome","text":"<p>Now that the genome is prepared. Sequencing reads can be aligned.</p> <p>Information required:</p> <ul> <li>Where the sequence information is stored (e.g. fastq files ...) ?</li> <li>What kind of sequencing: Single End or Paired end ?</li> <li>Where are stored the indexes and the genome? </li> <li> <p>Where will the mapping files be stored?</p> </li> <li> <p>Now, lets move one folder up (into the RNA_seq folder):</p> </li> </ul> <p><pre><code>cd ..\n ls\n</code></pre> <pre><code>    Genome  QC  Raw  Trimmed\n</code></pre></p> <p>Let's map one of our sample to the genome</p> <p><pre><code>hisat2 -x Genome/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel -U Raw/SRR014335-chr1.fastq -S SRR014335.sam\n</code></pre> ```125090 reads; of these:   125090 (100.00%) were unpaired; of these:     20537 (16.42%) aligned 0 times     85066 (68.00%) aligned exactly 1 time     19487 (15.58%) aligned &gt;1 times 83.58% overall alignment rate <pre><code>!!! quote \"\"\n\n    * **-x** The basename of the index for the reference genome. \n    * **-U** Comma-separated list of files containing unpaired reads to be aligned\n    * **-S** File to write SAM alignments to. By default, alignments are written to the \u201cstandard out\u201d or \u201cstdout\u201d filehandle  \n\n\nNow we need to align all the rest of the samples.\n\n```bash\npwd\n</code></pre> <pre><code>    /home/$USER/RNA_seq/\n</code></pre> <pre><code>mkdir Mapping\nls\n</code></pre> <pre><code>    Genome  Mapping  QC  Raw  SRR014335.sam  Trimmed\n</code></pre></p> <p>let's use a for loop to process our samples:</p> <p><pre><code>cd Trimmed\nls\n</code></pre> <pre><code>    SRR014335-chr1.fastq  SRR014336-chr1.fastq  SRR014337-chr1.fastq  SRR014339-chr1.fastq  SRR014340-chr1.fastq  SRR014341-chr1.fastq\n</code></pre> <pre><code>for filename in *\ndo\nbase=$(basename ${filename} .trimmed.fastq)\nhisat2 -p 4 -x ../Genome/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel -U $filename -S ../Mapping/${base}.sam --summary-file ../Mapping/${base}_summary.txt\ndone\n</code></pre></p> <p>Now we can explore our SAM files.</p> <p><pre><code>cd ../Mapping\nls\n</code></pre> <pre><code>SRR014335-chr1.sam          SRR014336-chr1_summary.txt  SRR014339-chr1.sam          SRR014340-chr1_summary.txt\nSRR014335-chr1_summary.txt  SRR014337-chr1.sam          SRR014339-chr1_summary.txt  SRR014341-chr1.sam\nSRR014336-chr1.sam          SRR014337-chr1_summary.txt  SRR014340-chr1.sam          SRR014341-chr1_summary.txt\n</code></pre></p>"},{"location":"4_mappingANDcount/#converting-sam-files-to-bam-files","title":"Converting SAM files to BAM files","text":"<p>The SAM file, is a tab-delimited text file that contains information for each individual read and its alignment to the genome. While we do not have time to go into detail about the features of the SAM format, the paper by Heng Li et al. provides a lot more detail on the specification.</p> <p>The compressed binary version of SAM is called a BAM file. We use this version to reduce size and to allow for indexing, which enables efficient random access of the data contained within the file.</p>"},{"location":"4_mappingANDcount/#a-quick-look-into-the-sam-file","title":"A quick look into the sam file","text":"<p><pre><code>less SRR014335-chr1.sam \n</code></pre> The file begins with a header, which is optional. The header is used to describe the source of data, reference sequence, method of alignment, etc., this will change depending on the aligner being used. Following the header is the alignment section. Each line that follows corresponds to alignment information for a single read. Each alignment line has 11 mandatory fields for essential mapping information and a variable number of other fields for aligner specific information. An example entry from a SAM file is displayed below with the different fields highlighted.</p> <p>We will convert the SAM file to BAM format using the samtools program with the <code>view</code> command </p> <pre><code>module load SAMtools/1.15.1-GCC-11.3.0\n\nfor filename in *.sam\ndo\nbase=$(basename ${filename} .sam)\nsamtools view -S -b ${filename} -o ${base}.bam\ndone\n</code></pre> <ul> <li>-S input is in SAM format (it's here as a placeholder as SAMtoools version 1.10 or above  will pick up the correct format automatically by examining the first few characters of input.)</li> <li>-b Output is in BAM format</li> </ul> <p><pre><code>ls\n</code></pre> <pre><code>SRR014335-chr1.bam  SRR014336-chr1.bam  SRR014337-chr1.bam  SRR014339-chr1.bam  SRR014340-chr1.bam  SRR014341-chr1.bam\nSRR014335-chr1.sam  SRR014336-chr1.sam  SRR014337-chr1.sam  SRR014339-chr1.sam  SRR014340-chr1.sam  SRR014341-chr1.sam\n</code></pre></p> <p>Next we sort the BAM file using the sort command from samtools. <code>-o</code> tells the command where to write the output.</p> <p>SAM/BAM files can be sorted in multiple ways, e.g. by location of alignment on the chromosome, by read name, etc. It is important to be aware that different alignment tools will output differently sorted SAM/BAM, and different downstream tools require differently sorted alignment files as input.</p> <pre><code>for filename in *.bam\ndo\nbase=$(basename ${filename} .bam)\nsamtools sort -o ${base}_sorted.bam ${filename}\ndone\n</code></pre> <p>You can use samtools to learn more about the bam file as well.</p>"},{"location":"4_mappingANDcount/#some-stats-on-your-mapping","title":"Some stats on your mapping:","text":"<p><pre><code>samtools flagstat SRR014335-chr1_sorted.bam \n</code></pre> <pre><code>156984 + 0 in total (QC-passed reads + QC-failed reads)\n31894 + 0 secondary\n0 + 0 supplementary\n0 + 0 duplicates\n136447 + 0 mapped (86.92% : N/A)\n0 + 0 paired in sequencing\n0 + 0 read1\n0 + 0 read2\n0 + 0 properly paired (N/A : N/A)\n0 + 0 with itself and mate mapped\n0 + 0 singletons (N/A : N/A)\n0 + 0 with mate mapped to a different chr\n0 + 0 with mate mapped to a different chr (mapQ&gt;=5)\n</code></pre> Basic statistics shown by <code>flagstat</code> will be slightly different from those in the summary file generated by HISAT2 due to different \"totals\" that are used for comparisons. <code>flagstat</code> compares the number of alignments; HISAT2 compares the number of reads mapped. This is because reads can be mapped/aligned to more than one reference location, and these reads have a \"primary\" and \"secondary\" alignment (see section 1.2 of the SAM specifications). For example, the percent overall alignment in the HISAT2 summary will be equivalent to the percent primary mapped evaluated by <code>flagstat</code>. To get number of reads that aligned 0 times (summary file), the equivalent statistic from <code>flagstat</code> would be subtracting the number of mapped reads from the number of total alignments.</p>"},{"location":"4_mappingANDcount/#multiqc-hisat2-output","title":"MultiQC: <code>HISAT2</code> output","text":"<ul> <li>The HISAT2 output data can also be incorporated into the MultiQC report the next time it is run.</li> </ul> <pre><code>cd ~/RNA_seq/MultiQC\ncp ../Mapping/*summary* ./\nmultiqc .\n</code></pre> <p>Please note: running HISAT2 with either option <code>--summary-file</code> or older versions (&lt; v2.1.0) gives log output identical to Bowtie2. These logs are indistinguishable and summary statistics will appear in MultiQC reports labelled as Bowtie2.</p>"},{"location":"4_mappingANDcount/#read-summarization","title":"Read Summarization","text":"<p>Sequencing reads often need to be assigned to genomic features of interest after they are mapped to the reference genome. This process is often called read summarization or read quantification. Read summarization is required by a number of downstream analyses such as gene expression analysis and histone modification analysis. The output of read summarization is a count table, in which the number of reads assigned to each feature in each library is recorded.</p>"},{"location":"4_mappingANDcount/#counting","title":"Counting","text":"<ul> <li>We need to do some counting!</li> <li>Want to generate count data for each gene (actually each exon) - how many reads mapped to each exon in the genome, from each of our samples?</li> <li>Once we have that information, we can start thinking about how to determine which genes were differentially expressed in our study.</li> </ul>"},{"location":"4_mappingANDcount/#subread-and-featurecounts","title":"Subread and FeatureCounts","text":"<ul> <li>The featureCounts tool from the Subread package can be used to count how many reads aligned to each genome feature (exon).</li> <li>Need to specify the annotation information (.gtf file)  You can process all the samples at once:</li> </ul> <p><pre><code>module load Subread/2.0.3-GCC-11.3.0\npwd\n</code></pre> <pre><code>/home/$USER/RNA_seq\n</code></pre> <pre><code>mkdir Counts\ncd Counts\nfeatureCounts -a ../Genome/Saccharomyces_cerevisiae.R64-1-1.99.gtf -o ./yeast_counts.txt -T 2 -t exon -g gene_id ../Mapping/*sorted.bam\n</code></pre></p> <ul> <li>-a Name of an annotation file. GTF/GFF format by default</li> <li>-o Name of output file including read counts</li> <li>-T Specify the number of threads/CPUs used for mapping. 1 by default</li> <li>-t Specify feature type in GTF annotation. 'exon' by default. Features used for read counting will be extracted from annotation using the provided value.</li> <li>-g Specify attribute type in GTF annotation. 'gene_id' by default. Meta-features used for read counting will be extracted from annotation using the provided value.</li> </ul>"},{"location":"4_mappingANDcount/#multiqc-featurecounts-output","title":"MultiQC: featureCounts output","text":"<ul> <li>If the samples are processed individually, the output data can be incorporated into the MultiQC report the next time it is run.</li> </ul> <pre><code>cd ../MultiQC\ncp ../Counts/* .\nmultiqc .\n</code></pre> <p>Back to homepage</p>"},{"location":"5_rnaseq-diffexp/","title":"Differential Expression Analysis","text":"<p>Objectives</p> <ul> <li>Import count data into R and familiarise yourself with the format of this data</li> <li>Identify differentially expressed genes using LIMMA, DESeq2 and edgeR</li> <li>Recognise the impact of different methods on differentially expressed gene sets</li> </ul> <p> </p>"},{"location":"5_rnaseq-diffexp/#recap","title":"Recap","text":"<ul> <li>In the last section we worked through the process of quality     assessment and alignment for RNA-seq data</li> <li>This typically takes place on the command line, but can also be done     from within R.</li> <li>The end result was the generation of count data (counts of reads     aligned to each gene, per sample) using the FeatureCounts command     from Subread/Rsubread.</li> <li>Now that we\u2019ve got count data in R, we can begin our differential     expression analysis.</li> </ul>"},{"location":"5_rnaseq-diffexp/#data-set-reminder","title":"Data set reminder","text":"<ul> <li>Data obtained from yeast RNA-seq experiment,     Lee     et al 2008 </li> <li>Wild-type versus RNA degradation mutants</li> <li>Six samples (3 WT / 3 MT)</li> <li> <p>NOTE: since we are dealing with an RNA degradation mutant yeast     strain, we will see MAJOR transcriptomic differences between the     wild-type and mutant groups (usually the differences you observe in     a typical RNA-seq study wouldn\u2019t be this extreme).</p> </li> <li> <p>Slides: lecture_differential_expression.pdf</p> </li> </ul>"},{"location":"5_rnaseq-diffexp/#getting-organised","title":"Getting organised","text":""},{"location":"5_rnaseq-diffexp/#create-an-rstudio-project","title":"Create an RStudio project","text":"<p>NOTE: skip to the next section (\u201cCount Data\u201d) if you are working within a Jupyter notebook on NeSI. If you are using RStudio on NeSI, then keep following the instructions below.</p> <p>One of the first benefits we will take advantage of in RStudio is something called an RStudio Project. An RStudio project allows you to more easily:</p> <ul> <li>Save data, files, variables, packages, etc. related to a specific     analysis project</li> <li>Restart work where you left off</li> <li>Collaborate, especially if you are using version control such as     git.</li> </ul> <p>To create a project:</p> <ul> <li>Open RStudio and go to the File menu, and click New Project.</li> <li>In the window that opens select Existing Project, and browse to the     RNA_seq folder.</li> <li>Finally, click Create Project.</li> </ul> <p>To create a new file where we will type our R code:</p> <ul> <li>In RStudio, go to the File menu, and choose New File and then R Script</li> <li>This will open a new panel where we can save our R command.</li> <li>Initially the new file is called untitled - use Save As from the File menu to save the file as <code>yeast_data.R</code> and continue saving regularly as you work. </li> </ul>"},{"location":"5_rnaseq-diffexp/#count-data","title":"Count data","text":"<p>Note: I have now aligned the data for ALL CHROMOSOMES and generated counts, so we are working with data from all 7127 genes.</p> <p>Let\u2019s look at our data set and perform some basic checks before we do a differential expression analysis.</p> <p>NB - the keyboard shortcut for <code>%&gt;%</code> (R's pipe command) is <code>shift-control-m</code> (also <code>shift-command-m</code> on Mac - both work).</p> <pre><code>library(dplyr)\nfcData = read.table('yeast_counts_all_chr.txt', sep='\\t', header=TRUE)\nfcData %&gt;% head()\n</code></pre> <pre><code>##      Geneid Chr Start   End Strand Length ...STAR.SRR014335.Aligned.out.sam\n## 1   YDL248W  IV  1802  2953      +   1152                                52\n## 2 YDL247W-A  IV  3762  3836      +     75                                 0\n## 3   YDL247W  IV  5985  7814      +   1830                                 2\n## 4   YDL246C  IV  8683  9756      -   1074                                 0\n## 5   YDL245C  IV 11657 13360      -   1704                                 0\n## 6   YDL244W  IV 16204 17226      +   1023                                 6\n##   ...STAR.SRR014336.Aligned.out.sam ...STAR.SRR014337.Aligned.out.sam\n## 1                                46                                36\n## 2                                 0                                 0\n## 3                                 4                                 2\n## 4                                 0                                 1\n## 5                                 3                                 0\n## 6                                 6                                 5\n##   ...STAR.SRR014339.Aligned.out.sam ...STAR.SRR014340.Aligned.out.sam\n## 1                                65                                70\n## 2                                 0                                 1\n## 3                                 6                                 8\n## 4                                 1                                 2\n## 5                                 5                                 7\n## 6                                20                                30\n##   ...STAR.SRR014341.Aligned.out.sam\n## 1                                78\n## 2                                 0\n## 3                                 5\n## 4                                 0\n## 5                                 4\n## 6                                19\n</code></pre> <p>Check dimensions:</p> <pre><code>dim(fcData)\n</code></pre> <pre><code>## [1] 7127   12\n</code></pre> <pre><code>names(fcData)\n</code></pre> <pre><code>##  [1] \"Geneid\"                            \"Chr\"                              \n##  [3] \"Start\"                             \"End\"                              \n##  [5] \"Strand\"                            \"Length\"                           \n##  [7] \"...STAR.SRR014335.Aligned.out.sam\" \"...STAR.SRR014336.Aligned.out.sam\"\n##  [9] \"...STAR.SRR014337.Aligned.out.sam\" \"...STAR.SRR014339.Aligned.out.sam\"\n## [11] \"...STAR.SRR014340.Aligned.out.sam\" \"...STAR.SRR014341.Aligned.out.sam\"\n</code></pre> <p>Rename data columns to reflect group membership</p> <pre><code>names(fcData)[7:12] = c(\"WT1\", \"WT2\", \"WT3\", \"MT1\", \"MT2\", \"MT3\")\n\nfcData %&gt;% head()\n</code></pre> <pre><code>##      Geneid Chr Start   End Strand Length WT1 WT2 WT3 MT1 MT2 MT3\n## 1   YDL248W  IV  1802  2953      +   1152  52  46  36  65  70  78\n## 2 YDL247W-A  IV  3762  3836      +     75   0   0   0   0   1   0\n## 3   YDL247W  IV  5985  7814      +   1830   2   4   2   6   8   5\n## 4   YDL246C  IV  8683  9756      -   1074   0   0   1   1   2   0\n## 5   YDL245C  IV 11657 13360      -   1704   0   3   0   5   7   4\n## 6   YDL244W  IV 16204 17226      +   1023   6   6   5  20  30  19\n</code></pre> <p>Extract count data</p> <ul> <li>Remove annotation columns</li> <li>Add row names</li> </ul> <pre><code>counts = fcData[, 7:12]\nrownames(counts) = fcData$Geneid\ncounts %&gt;% head()\n</code></pre> <pre><code>##           WT1 WT2 WT3 MT1 MT2 MT3\n## YDL248W    52  46  36  65  70  78\n## YDL247W-A   0   0   0   0   1   0\n## YDL247W     2   4   2   6   8   5\n## YDL246C     0   0   1   1   2   0\n## YDL245C     0   3   0   5   7   4\n## YDL244W     6   6   5  20  30  19\n</code></pre>"},{"location":"5_rnaseq-diffexp/#visualising-the-data","title":"Visualising the data","text":"<p>Data are highly skewed (suggests that logging might be useful):</p> <pre><code>boxplot(as.matrix(counts) ~ col(counts))\n</code></pre> <p></p> <p>Some genes have zero counts:</p> <pre><code>colSums(counts == 0)\n</code></pre> <pre><code>## WT1 WT2 WT3 MT1 MT2 MT3 \n## 562 563 573 437 425 435\n</code></pre> <p>Log transformation (add 0.5 to avoid log(0) issues):</p> <pre><code>logCounts = log2(as.matrix(counts)+ 0.5)\n</code></pre> <p>Now we can see the per-sample distributions more clearly:</p> <pre><code>boxplot(as.matrix(logCounts) ~ col(logCounts))\n</code></pre> <p></p> <p>Density plots are also a good way to visualise the data:</p> <pre><code>lineColour = c(\"blue\", \"blue\", \"blue\", \"red\", \"red\", \"red\")\nlineColour\n</code></pre> <pre><code>## [1] \"blue\" \"blue\" \"blue\" \"red\"  \"red\"  \"red\"\n</code></pre> <pre><code>plot(density(logCounts[,1]), ylim=c(0,0.3), col=lineColour[1])\nfor(i in 2:ncol(logCounts)) lines(density(logCounts[,i]), col=lineColour[i])\n</code></pre> <p></p> <p>The boxplots and density plots show clear differences between the sample groups - are these biological, or experimental artifacts? (often we don\u2019t know).</p> <p>Remember: the wild-type and mutant yeast strains are VERY different. You wouldn\u2019t normally see this amount of difference in the distributions between the groups.</p>"},{"location":"5_rnaseq-diffexp/#read-counts-per-sample","title":"Read counts per sample","text":"<p>Normalisation process (slightly different for each analysis method) takes \u201clibrary size\u201d (number of reads generated for each sample) into account.</p> <ul> <li>A good blog about normalization:     Link</li> </ul> <pre><code>colSums(counts)\n</code></pre> <pre><code>##     WT1     WT2     WT3     MT1     MT2     MT3 \n## 4915975 4892227 4778158 4618409 4719413 4554283\n</code></pre> <p>Visualise via bar plot</p> <pre><code>colSums(counts) %&gt;% barplot(., ylab=\"Reads mapped per sample\")\n</code></pre> <p></p> <p>Now we are ready for differential expression analysis</p>"},{"location":"5_rnaseq-diffexp/#detecting-differential-expression","title":"Detecting differential expression:","text":"<p>We are going to identify genes that are differential expressed using 3 different packages (time allowing) and compare the results.</p> <p>But first, lets take a brief aside, and talk about the process of detecting genes that have undergone a statistically significance change in expression between the two groups.</p> <p>LET'S DIG INTO THINGS A LITTLE DEEPER: lecture_differential_expression.pdf</p>"},{"location":"5_rnaseq-diffexp/#limma","title":"Limma","text":"<ul> <li>Limma can be used for analysis, by transforming the RNA-seq count     data in an appropriate way (log-scale normality-based assumption     rather than Negative Binomial for count data)</li> <li>Use data transformation and log to satisfy normality assumptions     (CPM = Counts per Million).</li> </ul> <pre><code>library(limma)\nlibrary(edgeR)\n\ndge = DGEList(counts=counts)\ndge = calcNormFactors(dge)\nlogCPM = cpm(dge, log=TRUE, prior.count=3)\n\noptions(width=100)\nhead(logCPM, 3)\n</code></pre> <pre><code>##                  WT1        WT2        WT3        MT1        MT2        MT3\n## YDL248W    3.7199528  3.5561232  3.2538405  3.6446399  3.7156488  3.9155366\n## YDL247W-A -0.6765789 -0.6765789 -0.6765789 -0.6765789 -0.3140297 -0.6765789\n## YDL247W    0.1484688  0.6727144  0.1645731  0.7843936  1.0395626  0.6349276\n</code></pre>"},{"location":"5_rnaseq-diffexp/#aside-rpkm","title":"Aside: RPKM","text":"<p>We can use R to generate RPKM values (or FPKM if using paired-end reads):</p> <ul> <li>Need gene length information to do this</li> <li>Can get this from<code>goseq</code> package (we\u2019ll use this later for our     pathway analysis)</li> </ul> <pre><code>library(goseq)\ngeneLengths = getlength(rownames(counts), \"sacCer2\",\"ensGene\")\nrpkmData = rpkm(dge, geneLengths)\nrpkmData %&gt;% round(., 2) %&gt;% head()\n</code></pre> <pre><code>##             WT1  WT2  WT3   MT1   MT2   MT3\n## YDL248W   10.89 9.66 7.73 10.30 10.85 12.55\n## YDL247W-A  0.00 0.00 0.00  0.00  2.35  0.00\n## YDL247W    0.26 0.53 0.27  0.60  0.78  0.51\n## YDL246C    0.00 0.00 0.23  0.17  0.33  0.00\n## YDL245C    0.00 0.43 0.00  0.54  0.73  0.44\n## YDL244W    1.41 1.42 1.21  3.57  5.24  3.44\n</code></pre> <pre><code>range(rpkmData, na.rm=TRUE)\n</code></pre> <pre><code>## [1]     0.00 69786.58\n</code></pre> <p>Compare RPKM to logCPM</p> <pre><code>par(mfrow=c(2,3))\nfor(i in 1:ncol(rpkmData)){\n  plot(logCPM[,i], log2(rpkmData[,i]), pch='.', \n       xlab=\"logCPM\", ylab=\"RPKM\", main=colnames(logCPM)[i])\n}\n</code></pre> <p></p> <p>We\u2019re NOT going to use RPKM data here. I just wanted to show you how to calculate it, and how it relates to the logCPM data</p>"},{"location":"5_rnaseq-diffexp/#back-to-the-analysis-using-logcpm","title":"Back to the analysis\u2026 (using logCPM)","text":"<p>What if we just did a t-test?</p> <pre><code>## The beeswarm package is great for making jittered dot plots\nlibrary(beeswarm)\n\n# Specify \"conditions\" (groups: WT and MT)\nconds = c(\"WT\",\"WT\",\"WT\",\"MT\",\"MT\",\"MT\")\n\n## Perform t-test for \"gene number 6\" (because I like that one...)\nt.test(logCPM[6,] ~ conds)\n</code></pre> <pre><code>## \n##  Welch Two Sample t-test\n## \n## data:  logCPM[6, ] by conds\n## t = 7.0124, df = 2.3726, p-value = 0.01228\n## alternative hypothesis: true difference in means is not equal to 0\n## 95 percent confidence interval:\n##  0.5840587 1.9006761\n## sample estimates:\n## mean in group MT mean in group WT \n##         2.244310         1.001943\n</code></pre> <pre><code>beeswarm(logCPM[6,] ~ conds, pch=16, ylab=\"Expression (logCPM)\", xlab=\"Group\",\n         main=paste0(rownames(logCPM)[6], \": MT vs WT\"))\n</code></pre> <p></p> <ul> <li>we basically want to do this sort of analysis, for every gene</li> <li>we\u2019ll use a slightly more sophisticated approach though</li> </ul> <p>However, before we get to statistical testing, we (might) first need to do a little bit more normalisation.</p>"},{"location":"5_rnaseq-diffexp/#limma-voom","title":"Limma: voom","text":"<ul> <li>The \u201cvoom\u201d function estimates relationship between the mean and the     variance of the logCPM data, normalises the data, and creates     \u201cprecision weights\u201d for each observation that are incorporated into     the limma analysis.</li> </ul> <pre><code>design = model.matrix(~conds)\ndesign\n</code></pre> <pre><code>##   (Intercept) condsWT\n## 1           1       1\n## 2           1       1\n## 3           1       1\n## 4           1       0\n## 5           1       0\n## 6           1       0\n## attr(,\"assign\")\n## [1] 0 1\n## attr(,\"contrasts\")\n## attr(,\"contrasts\")$conds\n## [1] \"contr.treatment\"\n</code></pre> <pre><code>v = voom(dge, design, plot=TRUE)\n</code></pre>"},{"location":"5_rnaseq-diffexp/#voom-impact-on-samples","title":"Voom: impact on samples","text":"<p>Mainly affects the low-end (low abundance genes)</p> <pre><code>par(mfrow=c(2,3))\nfor(i in 1:ncol(logCPM)){\n  plot(logCPM[,i], v$E[,i], xlab=\"LogCPM\",\n       ylab=\"Voom\",main=colnames(logCPM)[i])\n  abline(0,1)\n}\n</code></pre> <p></p> <p>Hasn\u2019t removed the differences between the groups</p> <pre><code>boxplot(v$E ~ col(v$E))\n</code></pre> <p></p> <pre><code>lineColour = ifelse(conds==\"MT\", \"red\", \"blue\")\nlineColour\n</code></pre> <pre><code>## [1] \"blue\" \"blue\" \"blue\" \"red\"  \"red\"  \"red\"\n</code></pre> <pre><code>plot(density(v$E[,1]), ylim=c(0,0.3), col=lineColour[1])\nfor(i in 2:ncol(logCPM)) lines(density(v$E[,i]), col=lineColour[i])\n</code></pre> <p></p> <p>We can deal with this via \u201cquantile normalisation\u201d. Specify</p> <pre><code>normalize=\"quantile\"\n</code></pre> <p>in the <code>voom</code> function.</p> <pre><code>q = voom(dge, design, plot=TRUE, normalize=\"quantile\")\n</code></pre> <p></p> <p>Quantile normalisation forces all of the distributions to be the same.</p> <ul> <li>it is a strong assumption, and can have a major impact on the     analysis</li> <li>potentially removing biological differences between groups.</li> </ul> <pre><code>par(mfrow=c(2,3))\nfor(i in 1:ncol(logCPM)){\n  plot(logCPM[,i], q$E[,i], xlab=\"LogCPM\",\n       ylab=\"Voom (+quantile norm)\",main=colnames(logCPM)[i])\n  abline(0,1)\n}\n</code></pre> <p></p> <pre><code>boxplot(q$E ~ col(q$E))\n</code></pre> <p></p> <pre><code>lineColour = ifelse(conds==\"MT\", \"red\", \"blue\")\nlineColour\n</code></pre> <pre><code>## [1] \"blue\" \"blue\" \"blue\" \"red\"  \"red\"  \"red\"\n</code></pre> <pre><code>plot(density(q$E[,1]), ylim=c(0,0.3), col=lineColour[1])\nfor(i in 2:ncol(logCPM)) lines(density(q$E[,i]), col=lineColour[i])\n</code></pre> <p></p> <p>Note: we\u2019re NOT going to use the quantile normalised data here, but I wanted to show you how that method works.</p>"},{"location":"5_rnaseq-diffexp/#statistical-testing-fitting-a-linear-model","title":"Statistical testing: fitting a linear model","text":"<p>The next step is to fit a linear model to the transformed count data.</p> <p>The <code>lmFit()</code> command does this for each gene (all at once).</p> <pre><code>fit = lmFit(v, design)\n</code></pre> <p>The <code>eBayes()</code> function then performs Emprical Bays shrinkage estimation to adjust the variability estimates for each gene, and produce the moderated t-statistics.</p> <pre><code>fit = eBayes(fit)\n</code></pre> <p>We then summarize this information using the <code>topTable()</code> function, which list the genes in order of the strength of statistical support for differential expression (i.e., genes with lowest p-values are at the top of the list):</p> <pre><code>tt = topTable(fit, coef=ncol(design), n=nrow(counts))\nhead(tt)\n</code></pre> <pre><code>##            logFC  AveExpr        t      P.Value    adj.P.Val        B\n## YAL038W 2.313985 10.80214 319.5950 3.725452e-13 8.850433e-10 21.08951\n## YOR161C 2.568389 10.80811 321.9628 3.574510e-13 8.850433e-10 21.08187\n## YML128C 1.640664 11.40819 286.6167 6.857932e-13 9.775297e-10 20.84520\n## YMR105C 2.772539  9.65092 331.8249 3.018547e-13 8.850433e-10 20.16815\n## YHL021C 2.034496 10.17510 269.4034 9.702963e-13 1.152550e-09 20.07857\n## YDR516C 2.085424 10.05426 260.8061 1.163655e-12 1.184767e-09 19.87217\n</code></pre>"},{"location":"5_rnaseq-diffexp/#significant-genes","title":"Significant genes","text":"<p>Adjusted p-values less than 0.05:</p> <pre><code>sum(tt$adj.P.Val &lt; 0.05)\n</code></pre> <pre><code>## [1] 5140\n</code></pre> <p>Adjusted p-values less than 0.01:</p> <pre><code>sum(tt$adj.P.Val &lt;= 0.01)\n</code></pre> <pre><code>## [1] 4566\n</code></pre> <p>By default, limma uses FDR adjustment (but lets check):</p> <pre><code>sum(p.adjust(tt$P.Value, method=\"fdr\") &lt;= 0.01)\n</code></pre> <pre><code>## [1] 4566\n</code></pre> <p>Volcano plots are a popular method for summarising the <code>limma</code> output:</p> <pre><code>volcanoplot(fit, coef=2)\nabline(h=-log10(0.05))\n</code></pre> <p></p> <p>Significantly DE genes:</p> <pre><code>sigGenes = which(tt$adj.P.Val &lt;= 0.05)\nlength(sigGenes)\n</code></pre> <pre><code>## [1] 5140\n</code></pre> <pre><code>volcanoplot(fit, coef=2)\npoints(tt$logFC[sigGenes], -log10(tt$P.Value[sigGenes]), col='red', pch=16, cex=0.5)\n</code></pre> <p></p> <p>Significantly DE genes above fold-change threshold:</p> <pre><code>sigGenes = which(tt$adj.P.Val &lt;= 0.05 &amp; (abs(tt$logFC) &gt; log2(2)))\nlength(sigGenes)\n</code></pre> <pre><code>## [1] 1891\n</code></pre> <pre><code>volcanoplot(fit, coef=2)\npoints(tt$logFC[sigGenes], -log10(tt$P.Value[sigGenes]), col='red', pch=16, cex=0.5)\n</code></pre> <p></p> <p>Get the rows of top table with significant adjusted p-values - we\u2019ll save these for later to compare with the other methods.</p> <pre><code>limmaPadj = tt[tt$adj.P.Val &lt;= 0.01, ]\n</code></pre>"},{"location":"5_rnaseq-diffexp/#deseq2","title":"DESeq2","text":"<ul> <li>The DESeq2 package uses the Negative Binomial distribution to     model the count data from each sample.</li> <li>A statistical test based on the Negative Binomial distribution (via     a generalized linear model, GLM) can be used to assess differential     expression for each gene.</li> <li>Use of the Negative Binomial distribution attempts to accurately     capture the variation that is observed for count data.</li> </ul> <p>More information about DESeq2: article by Love et al, 2014</p> <p>Set up \u201cDESeq object\u201d for analysis:</p> <pre><code>library(DESeq2)\ndds = DESeqDataSetFromMatrix(countData = as.matrix(counts), \n                              colData = data.frame(conds=factor(conds)), \n                              design = formula(~conds))\n</code></pre> <p>Can access the count data in teh <code>dds</code> object via the <code>counts()</code> function:</p> <pre><code>counts(dds) %&gt;% head()\n</code></pre> <pre><code>##           WT1 WT2 WT3 MT1 MT2 MT3\n## YDL248W    52  46  36  65  70  78\n## YDL247W-A   0   0   0   0   1   0\n## YDL247W     2   4   2   6   8   5\n## YDL246C     0   0   1   1   2   0\n## YDL245C     0   3   0   5   7   4\n## YDL244W     6   6   5  20  30  19\n</code></pre> <p>Fit DESeq model to identify DE transcripts</p> <pre><code>dds = DESeq(dds)\n</code></pre> <p>Take a look at the results table</p> <pre><code>res = DESeq2::results(dds)\nknitr::kable(res[1:6,])\n</code></pre> baseMean log2FoldChange lfcSE stat pvalue padj YDL248W 56.2230316 -0.2339470 0.2278417 -1.0267961 0.3045165 0.3663639 YDL247W-A 0.1397714 -0.5255769 4.0804729 -0.1288030 0.8975136 0.9173926 YDL247W 4.2428211 -0.8100552 0.8332543 -0.9721584 0.3309718 0.3948536 YDL246C 0.6182409 -1.0326364 2.1560899 -0.4789394 0.6319817 0.6915148 YDL245C 2.8486580 -1.9781751 1.1758845 -1.6822869 0.0925132 0.1230028 YDL244W 13.0883354 -1.5823354 0.5128788 -3.0852037 0.0020341 0.0032860 <p>Summary of differential gene expression</p> <pre><code>summary(res) \n</code></pre> <pre><code>## \n## out of 6830 with nonzero total read count\n## adjusted p-value &lt; 0.1\n## LFC &gt; 0 (up)       : 2520, 37%\n## LFC &lt; 0 (down)     : 2521, 37%\n## outliers [1]       : 0, 0%\n## low counts [2]     : 0, 0%\n## (mean count &lt; 0)\n## [1] see 'cooksCutoff' argument of ?results\n## [2] see 'independentFiltering' argument of ?results\n</code></pre> <p>Note: p-value adjustment</p> <ul> <li>The \u201cpadj\u201d column of the DESeq2 results (<code>res</code>) contains adjusted     p-values (FDR).</li> <li>Can use the <code>p.adjust</code> function to manually adjust the DESeq2     p-values if needed (e.g., to use Holm correction)</li> </ul> <pre><code># Remove rows with NAs\nres = na.omit(res)\n\n# Get the rows of \"res\" with significant adjusted p-values\nresPadj=res[res$padj &lt;= 0.05 , ]\n\n# Get dimensions\ndim(resPadj)\n</code></pre> <pre><code>## [1] 4811    6\n</code></pre> <p>Number of adjusted p-values less than 0.05</p> <pre><code>sum(res$padj &lt;= 0.05)\n</code></pre> <pre><code>## [1] 4811\n</code></pre> <p>Check that this is the same using p.adjust with FDR correction</p> <pre><code>sum(p.adjust(res$pvalue, method=\"fdr\") &lt;= 0.05)\n</code></pre> <pre><code>## [1] 4811\n</code></pre> <p>Number of Holm adjusted p-values less than 0.05</p> <pre><code>sum(p.adjust(res$pvalue, method=\"holm\") &lt;= 0.01)\n</code></pre> <pre><code>## [1] 3429\n</code></pre> <p>Sort summary list by p-value and save the table as a CSV file that can be read in Excel (or any other spreadhseet program).</p> <pre><code>res = res[order(res$padj),]\n\nwrite.csv(as.data.frame(res),file='deseq2.csv')\n</code></pre>"},{"location":"5_rnaseq-diffexp/#edger","title":"edgeR","text":"<ul> <li>The edgeR package also uses the negative binomial distribution to     model the RNA-seq count data.</li> <li>Takes an empirical Bayes approach to the statistical analysis, in a     similar way to how the <code>limma</code> package handles RNA-seq data.</li> </ul>"},{"location":"5_rnaseq-diffexp/#identify-degs-with-edgers-exact-method","title":"Identify DEGs with edgeR\u2019s \u201cExact\u201d Method","text":"<p>Load <code>edgeR</code> package</p> <pre><code>library(edgeR)\n</code></pre> <p>Construct <code>DGEList</code> object</p> <pre><code>y = DGEList(counts=counts, group=conds)\n</code></pre> <p>Calculate library size (counts per sample)</p> <pre><code>y = calcNormFactors(y)\n</code></pre> <p>Estimate common dispersion (overall variability)</p> <pre><code>y = estimateCommonDisp(y)\n</code></pre> <p>Estimate tagwise dispersion (per gene variability)</p> <pre><code>y = estimateTagwiseDisp(y)\n</code></pre>"},{"location":"5_rnaseq-diffexp/#edger-analysis-and-output","title":"edgeR analysis and output","text":"<p>Compute exact test for the negative binomial distribution.</p> <pre><code>et = exactTest(y) \n\nknitr::kable(topTags(et, n=4)$table)\n</code></pre> logFC logCPM PValue FDR YCR077C 13.098599 6.629306 0 0 snR71 -9.870811 8.294459 0 0 snR59 -8.752555 10.105453 0 0 snR53 -8.503101 7.687908 0 0 <p>Adjusted p-values</p> <pre><code>edge = as.data.frame(topTags(et, n=nrow(counts))) \nsum(edge$FDR &lt;= 0.05)\n</code></pre> <pre><code>## [1] 5242\n</code></pre> <pre><code>sum(p.adjust(edge$PValue, method=\"fdr\") &lt;= 0.05)\n</code></pre> <pre><code>## [1] 5242\n</code></pre> <p>Get the rows of \u201cedge\u201d with significant adjusted p-values</p> <pre><code>edgePadj = edge[edge$FDR &lt;= 0.05, ]\n</code></pre>"},{"location":"5_rnaseq-diffexp/#deseq2-vs-edger","title":"DESeq2 vs edgeR","text":"<p>Generate Venn diagram to compare DESeq2 and edgeR results.</p> <p>There is fairly good overlap:</p> <pre><code>library(gplots)\nsetlist = list(edgeRexact=rownames(edgePadj), DESeq2=rownames(resPadj))\nvenn(setlist)\n</code></pre> <p></p>"},{"location":"5_rnaseq-diffexp/#limma-vs-edger-vs-deseq2","title":"Limma vs edgeR vs DESeq2","text":"<p>Again, fairly good overlap across the three methods we\u2019ve looked at:</p> <pre><code>setlist = list(edgeRexact=rownames(edgePadj), \n                DESeq2=rownames(resPadj),\n                LimmaVoom=rownames(limmaPadj))\nvenn(setlist)\n</code></pre> <p></p>"},{"location":"5_rnaseq-diffexp/#summary","title":"Summary","text":"<ul> <li>Once we\u2019ve generated count data, there are a number of ways to     perform a differential expression analysis.<ul> <li>DESeq2 and edgeR model the count data, and assume a Negative     Binomial distribution</li> <li>Limma transforms (and logs) the data and assumes normality</li> </ul> </li> <li>Here we\u2019ve seen that these three approaches give quite similar     results.</li> <li>The next step in a \u201cstandard\u201d RNA-seq workflow is to perform     \u201cpathway analysis\u201d.</li> </ul>"},{"location":"5_rnaseq-diffexp/#save-limma-toptable-results-for-next-session","title":"Save limma topTable results for next session\u2026","text":"<pre><code>save(list='tt', file='topTable.RData')\n</code></pre> <p>Back to homepage</p>"},{"location":"6_over-representation_analysis/","title":"Over-representation analysis (Gene Ontology)","text":"<p>Objectives</p> <ul> <li>Identify enriched biological functions or processes within a list of differentially expressed genes</li> <li>Recognise the importance of gene length in over-representation analyses, and how to correct for this in your analysis</li> </ul> <p> </p> <ul> <li>Slides: lecture_annotation_pathways.pdf</li> </ul> <p>Over-representation Analysis (Boyle et al.\u00a02004) is a widely used approach to determine whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list, e.g.\u00a0a list of differentially expressed genes (DEGs).</p> <ul> <li>Can perform over-representation analysis online (e.g., Enrichr,     GeneSetDB, PantherDB), and also in R.</li> <li>The basic principles are to:<ul> <li>identify a collection of differentially expressed genes</li> <li>test to see if genes that are members of specific gene sets     (e.g., Reactome pathways, Gene Ontology categories) are     differentially expressed more often than would be expected by     chance.</li> </ul> </li> </ul> <p>Some caveats for RNA-seq data</p> <ul> <li>The gene-set analysis methods are applicable to transcriptomic data     from both microarrays and RNA-seq.</li> <li>One caveat, however, is that the results need to take gene length     into account.</li> <li>RNA-seq tends to produce higher expression levels (i.e., greater     counts) for longer genes: a longer transcript implies more aligned     fragments, and thus higher counts. This also gives these genes a     great chance of being statistically differentially expressed.</li> <li>Some gene sets (pathways, GO terms) tend to involve families of long     genes: if long genes have a great chance of being detected as     differentially expressed, then gene sets consisting of long genes     will have a great chance of appeared to be enriched in the analysis.</li> </ul>"},{"location":"6_over-representation_analysis/#goseq","title":"GOseq","text":"<ul> <li>The GOseq methodology     (Young     et al., 2010) overcomes this issue by allowing the     over-representation analysis to be adjusted for gene length.</li> <li>modification to hypergeometric sampling probability</li> <li>exact method (resampling) and an approximation-based method</li> <li>More recent publications have also applied this gene-length     correction to GSEA-based methods.</li> <li>Still not widely understood to be an issue when performing RNA-seq     pathway analysis, but REALLY important to take into account.</li> </ul>"},{"location":"6_over-representation_analysis/#results-from-the-young-et-al-2010-publication","title":"Results from the Young et al (2010) publication:","text":"<p> Proportion DE by gene length and reads</p> <p> Gene set ranks by standard analysis</p> <p> Gene set ranks by GOseq</p>"},{"location":"6_over-representation_analysis/#goseq-analysis","title":"GOseq analysis","text":"<p>Need to figure out if our organism is supported\u2026 (code is \u201csacCer\u201d)</p> <pre><code>library(dplyr)\nlibrary(goseq)\nsupportedOrganisms() %&gt;% head()\n</code></pre> <pre><code>##          Genome         Id  Id Description Lengths in geneLeneDataBase\n## 10      anoCar1    ensGene Ensembl gene ID                        TRUE\n## 11      anoGam1    ensGene Ensembl gene ID                        TRUE\n## 132     anoGam3                                                  FALSE\n## 12      apiMel2    ensGene Ensembl gene ID                        TRUE\n## 137 Arabidopsis                                                  FALSE\n## 56      bosTau2 geneSymbol     Gene Symbol                        TRUE\n##     GO Annotation Available\n## 10                    FALSE\n## 11                     TRUE\n## 132                    TRUE\n## 12                    FALSE\n## 137                    TRUE\n## 56                     TRUE\n</code></pre> <p>Easier to find if we use <code>View()</code> (NB - this only works in RStudio. Can\u2019t use if working in a Jupyter Notebook).</p> <pre><code>supportedOrganisms() %&gt;% View()\n</code></pre> <p>Define differentially expressed genes</p> <ul> <li>Create a vector of 0\u2019s and 1\u2019s to denote whether or not genes are     differentially expressed (limma analysis: topTable).</li> <li>Add gene names to the vector so that GOSeq knows which gene each     data point relates to.</li> </ul> <p>Load our topTable results from last session:</p> <pre><code>load('topTable.RData')\n</code></pre> <pre><code># Note: If you want to use tt from DESeq, replace $adj.P.Val with $padj below\n\ngenes = ifelse(tt$adj.P.Val &lt; 0.05, 1, 0) \nnames(genes) = rownames(tt)\nhead(genes)\n</code></pre> <pre><code>## YAL038W YOR161C YML128C YMR105C YHL021C YDR516C \n##       1       1       1       1       1       1\n</code></pre> <pre><code>table(genes)\n</code></pre> <pre><code>## genes\n##    0    1 \n## 1987 5140\n</code></pre>"},{"location":"6_over-representation_analysis/#calculate-gene-weights","title":"Calculate gene weights","text":"<ul> <li>Put genes into length-based \u201cbins\u201d, and plot length vs proportion     differentially expressed</li> <li>Likely restricts to only those genes with GO annotation</li> </ul> <pre><code>pwf=nullp(genes, \"sacCer1\", \"ensGene\")\n</code></pre>"},{"location":"6_over-representation_analysis/#inspect-output","title":"Inspect output","text":"<p>Report length (bias) and weight data per gene.</p> <pre><code>head(pwf)\n</code></pre> <pre><code>##         DEgenes bias.data       pwf\n## YAL038W       1      1504 0.8205505\n## YOR161C       1      1621 0.8205505\n## YML128C       1      1543 0.8205505\n## YMR105C       1      1711 0.8205505\n## YHL021C       1      1399 0.8205505\n## YDR516C       1      1504 0.8205505\n</code></pre>"},{"location":"6_over-representation_analysis/#gene-lengths-and-weights","title":"Gene lengths and weights","text":"<pre><code>par(mfrow=c(1,2))\nhist(pwf$bias.data,30)\nhist(pwf$pwf,30)\n</code></pre>"},{"location":"6_over-representation_analysis/#gene-length-vs-average-expression","title":"Gene length vs average expression","text":"<p>Is there an association between gene length and expression level?</p> <pre><code>library(ggplot2)\ndata.frame(logGeneLength = log2(pwf$bias.data), \n           avgExpr = tt$AveExpr) %&gt;% \n  ggplot(., aes(x=logGeneLength, y=avgExpr)) + \n  geom_point(size=0.2) + \n  geom_smooth(method='lm')\n</code></pre> <p></p> <p>How about gene length and statistical evidence supporting differential expression?</p> <p>(Kinda hard to see, but it is apparently there\u2026)</p> <pre><code>data.frame(logGeneLength = log2(pwf$bias.data), \n           negLogAdjP = -log10(tt$adj.P.Val)) %&gt;% \n  ggplot(., aes(x=logGeneLength, negLogAdjP)) + \n  geom_point(size=0.2) + \n  geom_smooth(method='lm')\n</code></pre> <p></p>"},{"location":"6_over-representation_analysis/#length-correction-in-goseq","title":"Length correction in GOSeq","text":"<ul> <li>Uses \u201cWallenius approximation\u201d to perform correction.</li> <li>Essentially it is performing a weighted Fisher\u2019s Exact Test, but     each gene in the 2x2 data does not contribute equally to the per     cell count - it instead contributes its weight (based on its     length).</li> <li>This means that a gene set (e.g., GO term) containing lots of     significant short genes will be considered more likely to be     enriched that a gene set with a similar proportion of long genes     that are differentially expressed.</li> </ul> <p>Run GOSeq with gene length correction:</p> <pre><code>GO.wall=goseq(pwf, \"sacCer1\", \"ensGene\")\n</code></pre>"},{"location":"6_over-representation_analysis/#output-wallenius-method","title":"Output: Wallenius method","text":"<pre><code>head(GO.wall)\n</code></pre> <pre><code>##        category over_represented_pvalue under_represented_pvalue numDEInCat\n## 1325 GO:0005622            1.817597e-17                        1       4298\n## 7912 GO:0110165            8.200109e-12                        1       4456\n## 5245 GO:0042254            9.441146e-12                        1        364\n## 3817 GO:0022613            1.355385e-11                        1        439\n## 5446 GO:0043226            2.516156e-11                        1       3826\n## 5449 GO:0043229            4.433252e-11                        1       3817\n##      numInCat                                 term ontology\n## 1325     5179                        intracellular       CC\n## 7912     5417           cellular anatomical entity       CC\n## 5245      395                  ribosome biogenesis       BP\n## 3817      482 ribonucleoprotein complex biogenesis       BP\n## 5446     4609                            organelle       CC\n## 5449     4599              intracellular organelle       CC\n</code></pre>"},{"location":"6_over-representation_analysis/#p-value-adjustment","title":"P-value adjustment","text":"<pre><code>GO.wall.padj = p.adjust(GO.wall$over_represented_pvalue, method=\"fdr\")\nsum(GO.wall.padj &lt; 0.05)\n</code></pre> <pre><code>## [1] 45\n</code></pre> <pre><code>GO.wall.sig = GO.wall$category[GO.wall.padj &lt; 0.05]\nlength(GO.wall.sig)\n</code></pre> <pre><code>## [1] 45\n</code></pre> <pre><code>head(GO.wall.sig)\n</code></pre> <pre><code>## [1] \"GO:0005622\" \"GO:0110165\" \"GO:0042254\" \"GO:0022613\" \"GO:0043226\"\n## [6] \"GO:0043229\"\n</code></pre>"},{"location":"6_over-representation_analysis/#filtering-by-gene-set-length","title":"Filtering by gene set length","text":"<p>We are usually not interested in pathways or ontology terms that involve large numbers of genes (they are often rather broad terms or mechanisms), so we can exclude these from the results (here we only include significant GO terms that involve less than 500 genes):</p> <pre><code>GO.wall[GO.wall.padj &lt; 0.05, ] %&gt;% filter(numInCat &lt; 500)\n</code></pre> Output <pre><code>##      category over_represented_pvalue under_represented_pvalue numDEInCat\n## 1  GO:0042254            9.441146e-12                1.0000000        364\n## 2  GO:0022613            1.355385e-11                1.0000000        439\n## 3  GO:0030684            3.348423e-08                1.0000000        163\n## 4  GO:0016072            3.873737e-08                1.0000000        274\n## 5  GO:0006364            4.532117e-08                1.0000000        259\n## 6  GO:0034470            2.776978e-07                1.0000000        360\n## 7  GO:0030490            9.891093e-07                0.9999998        111\n## 8  GO:0030687            1.502461e-06                1.0000000         62\n## 9  GO:0042274            2.616777e-06                0.9999993        134\n## 10 GO:0005730            3.753501e-06                1.0000000        264\n## 11 GO:0003735            3.799990e-06                1.0000000        194\n## 12 GO:0022626            4.824970e-06                0.9999984        140\n## 13 GO:0044391            6.732064e-06                1.0000000        202\n## 14 GO:0000462            1.221128e-05                0.9999977         99\n## 15 GO:0005840            1.780243e-05                0.9999942        221\n## 16 GO:0002181            2.156069e-05                0.9999913        169\n## 17 GO:0034660            7.782098e-05                0.9999571        409\n## 18 GO:0042273            8.604282e-05                0.9999745        117\n##    numInCat\n## 1       395\n## 2       482\n## 3       171\n## 4       299\n## 5       282\n## 6       401\n## 7       116\n## 8        62\n## 9       143\n## 10      292\n## 11      221\n## 12      156\n## 13      231\n## 14      104\n## 15      254\n## 16      191\n## 17      467\n## 18      126\n##                                                                                        term\n## 1                                                                       ribosome biogenesis\n## 2                                                      ribonucleoprotein complex biogenesis\n## 3                                                                               preribosome\n## 4                                                                    rRNA metabolic process\n## 5                                                                           rRNA processing\n## 6                                                                          ncRNA processing\n## 7                                                                    maturation of SSU-rRNA\n## 8                                                      preribosome, large subunit precursor\n## 9                                                        ribosomal small subunit biogenesis\n## 10                                                                                nucleolus\n## 11                                                       structural constituent of ribosome\n## 12                                                                       cytosolic ribosome\n## 13                                                                        ribosomal subunit\n## 14 maturation of SSU-rRNA from tricistronic rRNA transcript (SSU-rRNA, 5.8S rRNA, LSU-rRNA)\n## 15                                                                                 ribosome\n## 16                                                                  cytoplasmic translation\n## 17                                                                  ncRNA metabolic process\n## 18                                                       ribosomal large subunit biogenesis\n##    ontology\n## 1        BP\n## 2        BP\n## 3        CC\n## 4        BP\n## 5        BP\n## 6        BP\n## 7        BP\n## 8        CC\n## 9        BP\n## 10       CC\n## 11       MF\n## 12       CC\n## 13       CC\n## 14       BP\n## 15       CC\n## 16       BP\n## 17       BP\n## 18       BP\n</code></pre>"},{"location":"6_over-representation_analysis/#go-terms","title":"GO terms","text":"<ul> <li>Can use the <code>GO.db</code> package to get more information about the     significant gene sets.</li> </ul> <pre><code>library(GO.db)\n\nGOTERM[[GO.wall.sig[1]]]\n</code></pre> <pre><code>## GOID: GO:0005622\n## Term: intracellular\n## Ontology: CC\n## Definition: The living contents of a cell; the matter contained within\n##     (but not including) the plasma membrane, usually taken to exclude\n##     large vacuoles and masses of secretory or ingested material. In\n##     eukaryotes it includes the nucleus and cytoplasm.\n## Synonym: internal to cell\n## Synonym: protoplasm\n## Synonym: nucleocytoplasm\n## Synonym: protoplast\n</code></pre> <p>NB - the code below is demonstrating the difference between running with and without the gene length correction that GOseq implements. You wouldn\u2019t usually work through this as part of a standard pathway analysis.</p>"},{"location":"6_over-representation_analysis/#run-goseq-without-gene-length-correction","title":"Run GOSeq without gene length correction","text":"<pre><code>GO.nobias=goseq(pwf, \"sacCer1\", \"ensGene\", method=\"Hypergeometric\")\n</code></pre> <p>Output: Hypergeomtric (Fisher) method</p> <pre><code>head(GO.nobias)\n</code></pre> <pre><code>##        category over_represented_pvalue under_represented_pvalue numDEInCat\n## 1325 GO:0005622            8.650971e-29                        1       4298\n## 7912 GO:0110165            3.271100e-21                        1       4456\n## 5446 GO:0043226            9.826546e-16                        1       3826\n## 2650 GO:0009987            1.330459e-15                        1       4146\n## 5449 GO:0043229            2.060920e-15                        1       3817\n## 5245 GO:0042254            7.222008e-11                        1        364\n##      numInCat                       term ontology\n## 1325     5179              intracellular       CC\n## 7912     5417 cellular anatomical entity       CC\n## 5446     4609                  organelle       CC\n## 2650     5023           cellular process       BP\n## 5449     4599    intracellular organelle       CC\n## 5245      395        ribosome biogenesis       BP\n</code></pre>"},{"location":"6_over-representation_analysis/#p-value-adjustment_1","title":"P-value adjustment","text":"<pre><code>GO.nobias.padj = p.adjust(GO.nobias$over_represented_pvalue, method=\"fdr\")\nsum(GO.nobias.padj &lt; 0.05)\n</code></pre> <pre><code>## [1] 44\n</code></pre> <pre><code>GO.nobias.sig = GO.nobias$category[GO.nobias.padj &lt; 0.05]\nlength(GO.nobias.sig)\n</code></pre> <pre><code>## [1] 44\n</code></pre> <pre><code>head(GO.nobias.sig)\n</code></pre> <pre><code>## [1] \"GO:0005622\" \"GO:0110165\" \"GO:0043226\" \"GO:0009987\" \"GO:0043229\"\n## [6] \"GO:0042254\"\n</code></pre>"},{"location":"6_over-representation_analysis/#compare-with-and-without-adjustment","title":"Compare with and without adjustment","text":"<pre><code>library(gplots)\nvenn(list(GO.wall=GO.wall.sig, GO.nobias=GO.nobias.sig))\n</code></pre> <p>Extract out the different parts of the Venn diagram (yes, there are definitely better ways to do this).</p> <pre><code>## Only significant in Hypergeomtric analysis\nonlySig.nobias = setdiff(GO.nobias.sig, GO.wall.sig)\n\n## Only significant in Wallenius analysis\nonlySig.wall = setdiff(GO.wall.sig, GO.nobias.sig)\n\n## Significant in both\nsig.wall.nobias = intersect(GO.wall.sig, GO.nobias.sig)\n</code></pre>"},{"location":"6_over-representation_analysis/#gene-lengths-and-go-term-membership","title":"Gene lengths and GO term membership","text":"<p>Can also extract gene length and GO membership information.</p> <pre><code>len=getlength(names(genes),\"sacCer1\",\"ensGene\")\n\nhead(len)\n</code></pre> <pre><code>## [1] 1504 1621 1543 1711 1399 1504\n</code></pre> <pre><code>go = getgo(names(genes),\"sacCer1\",\"ensGene\")\n\nnames(go) %&gt;% head()\n</code></pre> <pre><code>## [1] \"YAL038W\" \"YOR161C\" \"YML128C\" \"YMR105C\" \"YHL021C\" \"YDR516C\"\n</code></pre> <pre><code>class(go)\n</code></pre> <pre><code>## [1] \"list\"\n</code></pre> <pre><code>head(go[[1]])\n</code></pre> <pre><code>## [1] \"GO:0006082\" \"GO:0008150\" \"GO:0008152\" \"GO:0009987\" \"GO:0019752\"\n## [6] \"GO:0032787\"\n</code></pre> <pre><code>head(go[[2]])\n</code></pre> <pre><code>## [1] \"GO:0006810\" \"GO:0008150\" \"GO:0009987\" \"GO:0051179\" \"GO:0051234\"\n## [6] \"GO:0055085\"\n</code></pre>"},{"location":"6_over-representation_analysis/#getting-fancy","title":"Getting fancy\u2026","text":"<p>Figure out which genes are in the significant GO groups, and then gets their lengths.</p> <pre><code>lengths.onlySig.nobias = list()\n\nfor(i in 1:length(onlySig.nobias)){\n  inGo = lapply(go, function(x)  onlySig.nobias[i] %in% x) %&gt;% unlist()\n  lengths.onlySig.nobias[[i]] = len[inGo]\n}\n\nlengths.onlySig.wall = list()\n\nfor(i in 1:length(onlySig.wall)){\n  inGo = lapply(go, function(x)  onlySig.wall[i] %in% x) %&gt;% unlist()\n  lengths.onlySig.wall[[i]] = len[inGo]\n}\n</code></pre>"},{"location":"6_over-representation_analysis/#significant-hypergeometric-vs-wallenius","title":"Significant: Hypergeometric vs Wallenius","text":"<ul> <li>Only Hypergeometric (pink) vs only Wallenius (blue)</li> <li>Hypergeometric method is findings GO terms containing longer genes.</li> </ul> <p><pre><code>cols = rep(c(\"lightpink\", \"lightblue\"), c(10,7))\nboxplot(c(lengths.onlySig.nobias, lengths.onlySig.wall), col=cols)\n</code></pre> </p>"},{"location":"6_over-representation_analysis/#all-significant-go-terms","title":"All significant GO terms","text":"<pre><code>lengths.sig.wall.nobias = list()\n\nfor(i in 1:length(sig.wall.nobias)){\n  inGo = lapply(go, function(x)  sig.wall.nobias[i] %in% x) %&gt;% unlist()\n  lengths.sig.wall.nobias[[i]] = len[inGo]\n}\n</code></pre> <pre><code>cols = rep(c(\"lightpink\", grey(0.7), \"lightblue\"), c(10,37,7))\n\navgLength = lapply(c(lengths.onlySig.nobias, lengths.sig.wall.nobias, lengths.onlySig.wall),\n                    median) %&gt;% unlist()\n\noo = order(avgLength, decreasing=TRUE)\n</code></pre> <pre><code>boxplot(c(lengths.onlySig.nobias, lengths.sig.wall.nobias, lengths.onlySig.wall)[oo],\n        col=cols[oo], ylab=\"Gene Length\", xlab = \"GO term\")\n</code></pre>"},{"location":"6_over-representation_analysis/#gene-length-versus-p-value","title":"Gene length versus P-value","text":"<pre><code>avgLength.wall = lapply(c(lengths.onlySig.wall, lengths.sig.wall.nobias), median)\n\navgLength.nobias = lapply(c(lengths.onlySig.nobias, lengths.sig.wall.nobias), median)\n\ncols = rep(c(\"blue\", \"lightblue\", \"red\",\"lightpink\"),\n            c(length(lengths.onlySig.wall), length(lengths.sig.wall.nobias),\n              length(lengths.onlySig.nobias), length(lengths.sig.wall.nobias)))\n\nplot(c(avgLength.wall, avgLength.nobias), \n     -log(c(GO.nobias.padj[GO.nobias.padj &lt; 0.05], GO.wall.padj[GO.wall.padj &lt; 0.05])), \n     col=cols, pch=16, xlab=\"Median Gene Length\", ylab =\"-log(FDR adj-pval)\")\nlegend('topright', c(\"Only sig in NoBias\", \"Sig in both (nobias adjp)\", \n                     \"Sig in both (wal adjp)\", \"Only sig in Wall\"), \n       fill=c(\"red\", \"pink\", \"lightblue\", \"blue\"))\n</code></pre>"},{"location":"6_over-representation_analysis/#summary","title":"Summary","text":"<ul> <li>Once we\u2019ve generated count data, there are a number of ways to     perform a differential expression analysis.</li> <li>DESeq2 and edgeR model the count data, and assume a Negative     Binomial distribution</li> <li>Limma transforms (and logs) the data and assumes normality</li> <li>Here we\u2019ve seen that these three approaches give quite similar     results.</li> <li>For Gene Set analysis, gene length needs to be accounted for, since     longer transcripts are more likely to be found to be differentially     expressed.<ul> <li>GOSeq adjusts for transcript length to take this into account.</li> <li>It is also possible to use GOSeq with other types of annotation     (e.g., Reactome or KEGG pathways).</li> </ul> </li> </ul> <p>Back to homepage</p>"},{"location":"supp_1/","title":"Supplementary 1 - A Guide to RNA-Seq","text":"<p>Back to homepage</p>"},{"location":"supp_2/","title":"Supplementary 2 -Lecture notes : Introduction To Differential Expression Analysis","text":"<p>Back to homepage</p>"},{"location":"supp_3/","title":"Supplementary 3 - Lecture notes : Annotation Data &amp; Gene Set Analysis","text":"<p>Back to homepage</p>"}]}